Class gSeq(Of T)
    ' can we make a generic version of the seq class
    ' currently gets stuck with duplicate definition of the oArr class (which eludes me!!)
    
	' Emulates the MS ArrayList as follows
    ' 
    ' Constructors:     Implemented with enhancement
    '
    ' PROPERTIES
    ' ==========
    ' Capacity:         Implemented
    ' Count:            Implemented see also CountIt
    ' IsFixedSize:      Not Implemented
    ' IsReadOnly:       Not Implemented
    ' IsSynchronsed:    Not Implemented
    ' Item()            Implemented, Default Memeber
    ' SyncRoot          Not Implemented
    '
    ' METHODS
    ' =======
    ' Adaptor:          Not Implemented but see AddRange
    ' Add:              Implemented see also AddItems
    ' AddRange:         Implemented with enhancement
    ' BinarySearch:     Not Implemented See CountIt, FilterIt
    ' Clear             Implemented Sugar for RemoveAll 
    ' Clone:            Implemented - shallow copy of objects
    ' Contains          Implemented Sugar for HoldsItem, See Also LacksItem
    ' CopyTo:           Implemented with enhancement, see also Slice
    ' FixedSize:        Not Implemented
    ' GetENumerator     Not Implemented, Use Items for enumeration
    ' GetRange          Implemented Sugar for Slice
    ' IndexOf           Implemented partially
    ' Insert            Implemented
    ' InsertRange:      Implemented with enhancements
    ' LastIndexOf       Implemented with enhancements
    ' ReadOnly:         Not Implemented
    ' Remove:           Implemented
    ' RemoveRange       Implemented, sugar for Remove
    ' Repeat:           Implemented
    ' Reverse:          Implemented Partially
    ' SetRange:         Not Implemented
    ' Sort:             Not Implemented
    ' ToArray:          Implemented, Sugar for Items, for type conversion see Mapit
    ' TrimToSize        Implemented
    
    ' Additional facilities
    ' Where possible, methods are redefined as functions that return the instance of Me
    ' to allow chaining of methods
    '
    ' AddItems Add multiple items in one statement
    ' FirstIndex
    ' LastIndex
    ' LacksItem Sugar for 'Not HoldsItem'
    ' Join, Returns a single string if the items are strings
    ' CountIt
    ' FilterIt
    ' MaptIt
    ' Slice
    ' ToCollection
    ' IsQueryable
    ' IsNotQueryable
    ' HasOneItem
    ' HasItems
    ' HasAnyItems
    
    Attribute VB_GlobalNameSpace = False
    Attribute VB_Creatable = True
    Attribute VB_PredeclaredId = True
    Attribute VB_Exposed = True
    Option Explicit
    
    'Implements IIndexed
    
    Private Const MY_TYPENAME                       As String = "gSeq"
    Private Const DEFAULT_CHUNK                     As Long = 16
    Private Const FIRST_INDEX                       As Long = 1
    
    
	Private Type state
    
        Host                                        As variant
        LastIndex                                   As long
        Size                                        As long
  
    End Type

    Private s                                       As state

    ' The following are accepted
    
    ' ParamArray which is interpretee as follows.
    ' - No Items: empty seq of default size
    ' - If more than one item: Items in paramArray. Capacity is the number of items
    ' - If only one Item then
    ' - If number: Empty seq with specified capacity
    ' - If String: Items are characters: capcity is length of string
    ' - If Array: Items as provided by For Each on the array
    ' - Dictionaries: Items from the Items method.  Capcity is the count of the dictionary
    ' - Collection: Items from the collection.  Capacity is collection Count
    ' - Stack,Queue: Items as provided by the ToArray method, capcity is count.
    
     
     ' generic seq is purely twinBasic so we can drop the prohibition on using overloading
     
    [ DefaultMember ]
    Public Function Deb(ByVal ipCapacity As oI32) As Object
     	With New gSeq(Of T)
            Return ConstructInstance(ipCapacity)
        End With
    End Function
     
    Friend Function ConstructInstance(ByVal ipCapacity As oI32) As Object
        s.LastIndex = 0
        s.Size = ipCapacity.Val
        Resize
        Return Me
    End Function
    
    
    Public Function Deb(ByRef ipArray As oArr(Of T)) As Object
        With New gSeq(Of T)
            Return .ConstructInstance(ipArray)
        End With
    End Function

    Friend Function ConstructInstance(ByVal ipArray As oArr(Of T)) As Object
    	s.LastIndex = 0
        s.Size = ipArray.Count
        Resize
        
        Dim myIndex As Long
        For myIndex = 1 To s.Size
            Add ipArray.Val(myIndex)
        Next
        Return Me
    End Function
    
    
    Public Function Deb(ByRef ipString As T) As Object
        With New gSeq(Of T)
            Return .ConstructInstance(ipString)
        End With
    End Function
    
    Friend Function ConstructInstance(ByRef ipString As T) As Object
    
        s.Size = VBA.Len(ipString)
        Resize
        
        Dim myIndex As Variant
        For myIndex = 1 To s.Size
            s.Host(myIndex) = VBA.Mid$(ipString, myIndex, 1)
        Next
        
        ' Information has been added to the gseq so we now need to set lastindex appropriately
        s.LastIndex = s.Size
        Return Me
    End Function
    
    '  Public Function Deb(ByRef ipItems As Object) As object
    '     With New gseq(Of T)
    '         Return .ConstructInstance(ipItem)
    '     End With
    ' End Function
    
    ' Friend Function ConstructInstance(ByRef ipItems As object) As Object
    
    '     s.LastIndex = 0
    '     s.Size = ipItems.count
    '     Resize
        
    '     Dim myItems As iteritems = iteritems(ipItems)
    '     Do
    '     	add myItems.Item(0)
    '     Loop While myItems.movenext
        
    '     Return me
    ' End Function
    
    
    ' Friend Function ConstructInstance(ByVal ipFPA As Variant) As Object
        
    '     s.LastIndex = 0
    '     s.Size = DEFAULT_CHUNK
    '     Resize
        
    '     Dim myFPA As Variant = VarOp.ResolveParamArray(ipFPA)
        
    '     Dim myMeta As Meta = Meta.Deb(myFPA)
       
    '     Select Case True
        
    '         ' Case VBA.IsNull(ipFPA)
            
    '         '     ' There is nothing to add to the newly created instance so
    '         '     Return Me
            
    '         Case myMeta.IsNotQueryable
            
    '             ' There is nothing to add to the newly created instance so
    '             Return Me
                
            
    '         Case myMeta.IsString

    '             s.Size = myMeta.Size
    '             Resize
    '             AddKnownRange myFPA
            
            
    '         ' the case below fails when the cargo is not 0 based (i.e. a collection)
    '         Case myMeta.IsNumber
               
    '             ' A single number is treated as a capacity argument
    '             s.Size = CLng(myFPA)
    '             Resize
                   
           
    '         Case myMeta.IsArray
            
    '             ' Select Case True
                
    '             '     Case ArrayInfo.IsNotAllocated(ipFPA(myMeta.FirstRank.FirstIndex))
                    
    '             '         s.Size = DEFAULT_CHUNK
    '             '         Resize
            
    '             '     Case myMeta.HasOneItem
                    
    '             '         If VBA.IsArray(ipFPA(myMeta.FirstRank.FirstIndex)) Then
                        	
                    
    '                         s.Size = ((myMeta.Size \ DEFAULT_CHUNK) + 1) * DEFAULT_CHUNK
    '                         Resize
    '                         AddKnownRange myFPA' (myMeta.FirstRank.FirstIndex)
                            
    '                 '     Else
                        
    '                 '         s.Size = DEFAULT_CHUNK
    '                 '         Resize
    '                 '         Add ipFPA(myMeta.FirstRank.FirstIndex)
                        
    '                 '     End If
                        
    '                 ' Case Else
                    
    '                 '     s.Size = ((myMeta.Size \ DEFAULT_CHUNK) + 1) * DEFAULT_CHUNK
    '                 '     Resize
    '                 '     AddKnownRange ipFPA
                        
    '             'End Select
                 
            
    '         Case myMeta.IsItemByIndex0
            
    '             s.Size = ((myMeta.Size \ DEFAULT_CHUNK) + 1) * DEFAULT_CHUNK
    '             Resize
    '             AddKnownRange myFPA
                 
    '          Case myMeta.IsItemByIndex1
             
    '             s.Size = ((myMeta.Size \ DEFAULT_CHUNK) + 1) * DEFAULT_CHUNK
    '             Resize
    '             AddKnownRange myFPA
                 
    '          Case myMeta.IsItemByToArray
             
    '             s.Size = ((myMeta.Size \ DEFAULT_CHUNK) + 1) * DEFAULT_CHUNK
    '             Resize
    '             AddKnownRange myFPA
                 
    '          Case myMeta.IsItemByKey

    '             s.Size = ((myMeta.Size \ DEFAULT_CHUNK) + 1) * DEFAULT_CHUNK
    '             Resize
    '             AddKnownRange myFPA
                 
    '         Case Else
            
    '             ' adding a non enumerable object/item

    '             s.Size = DEFAULT_CHUNK
    '             Resize
    '             Add myFPA
                
    '     End Select

    '     Return Me

    ' End Function

    'Description(Adds a single item, returns index at which item is added.  For compatability with arraylist)
    Public Function Add(ByRef ipItem As T) As Long
        
         If VBA.IsObject(ipItem) Then
            Set s.Host(GetNextIndex) = ipItem
        Else
            s.Host(GetNextIndex) = ipItem
        End If
       Return s.LastIndex
       
    End Function
    
    
    '@Description("Adds one or more items as is")
    Public Function AddItems(ByRef ipItems As oArr(Of T)) As Object
        ' Revised 2022 Nov 25: To use for next
        If ipItems.IsNotAllocated Then
            Return Me
        End If
        
        ' for add items we don't try to interpret what an item is, we just add it
        Dim myIndex As Long
        For myIndex = 0 To ipItems.Count - 1
            Add ipItems.Val(myIndex)
        Next
        
        Return Me
        
    End Function
    

    '@Description("For internal use.  The container is known to be correct for the use below")
    Friend Function AddKnownRange(ByRef ipRange As Variant) As Object
       
        Dim myIter As IterItems = IterItems(ipRange)
        Do
            ' Dim myTo As
            Dim myTest As Variant = myIter(0)
            If VBA.IsObject(myIter.Item(0)) Then
                
                Set s.Host(GetNextIndex) = myIter.Item(0)
                
                
            Else
                
                s.Host(GetNextIndex) = myIter.Item(0)
                
                
            End If

        Loop While myIter.MoveNext

        Return Me

    End Function

    ' ' Adds a the items in a single container. To add a single container as a container use additems
    Public Function AddRange(ByVal ipRange As Variant) As Object
        
        Dim myMeta As Meta = Meta.Deb(ipRange)
        If myMeta.IsNotQueryable Then
            Return Me
        End If
        
        Return AddKnownRange(ipRange)

    End Function

    '@Description("Get the index of the next item in the seq")
    Public Function GetNextIndex() As Long

        s.LastIndex += 1
        If s.LastIndex > s.Size Then
            	
                s.Size += DEFAULT_CHUNK
                Resize

        End If

       Return s.LastIndex

    End Function

    'toDo: update so that we can request a slice as an array
    Public Function ToArray() As Variant
        
        Dim myArray As Variant = s.Host
        'S.Host is 1 based but we need to retturn an array that is zero
        'based to be consistent with how arrays behave
        If s.LastIndex = 0 Then
            ReDim Preserve myArray(0 To 0)
        Else
            ReDim Preserve myArray(0 To s.LastIndex - 1)
        End If
        Return myArray

    End Function

    
    Public Function Items() As Variant
        Items = Me.ToArray
    End Function

    '@DefaultMember
    Public Property Get Item(ByVal ipIndex As Long) As Variant 'Implements IIndexed.Item
        If ipIndex < FIRST_INDEX Or ipIndex > s.LastIndex Then
            Return CVErr(9&)
        Else
            Return s.Host(ipIndex)
        End If
    End Property

    Public Property Let Item(ByVal ipIndex As Long, ByRef ipItem As Variant) 'Implements IIndexed.Item
        s.Host(ipIndex) = ipItem
    End Property

    Public Property Set Item(ByVal ipIndex As Long, ByRef ipItem As Variant) 'Implements IIndexed.Item
    	Set s.Host(ipIndex) = ipItem
    End Property

    Public Function Init(ByRef ipItem As Variant) As Object
       If VBA.IsObject(ipItem) Then
            Return InitByObject(ipItem)
       Else
       	    Return InitByPrimitive(ipItem)
       End If
    End Function
    
    Private Function InitByPrimitive(ByRef ipItem As Variant) As Object
        Dim myIndex As Long
        For myIndex = FIRST_INDEX To LastIndex
            s.Host(myIndex) = ipItem
        Next
        Return Me
    End Function
    
    Private Function InitByObject(ByRef ipitem As Variant) As Object
        Dim myIndex As Long
        For myIndex = FIRST_INDEX To LastIndex
            s.Host(myIndex) = ipitem
        Next
        Return Me
    End Function
    
    Public Function Insert(ByVal ipIndex As Long, ParamArray ipElements() As Variant) As Object

        If ipIndex < 1 Or ipIndex > s.LastIndex Then
            Return Me
        End If
        
        If ArrayInfo.IsNotAllocated(ipElements) Then
             Return Me
        End If

        'Dim myPPA As Variant = Meta.Deb(ipElements)
        
        Return InsertRange(ipIndex, CVar(ipElements))
            
    End Function
    

    ' Public Function InsertKnownRange(ByVal ipIndex As Long, ByRef ipRange As Variant) as Object
    
    '     Dim myMeta As Meta = Meta(ipRange)
        
    ' End Function
    
    
    ' may need to check insertion below for when string is supplied
    Public Function InsertRange(ByVal ipIndex As Long, ParamArray ipParamarray() As Variant) As Object
   	
        If ipIndex < FIRST_INDEX Or ipIndex > s.LastIndex Then
            Return Me
        End If
      
        Dim myParamArray As Variant = VarOp.ResolveParamArray(ipParamarray)
        Dim myMeta As Meta = Meta(myParamArray)
        
        If myMeta.IsNotQueryable Then
            Return Me
        End If
        
        MoveUp ipIndex, myMeta.Size

        
        Dim myIter As IterItems = IterItems(myParamArray)
        Do
            'Assign s.Host(ipIndex), myIter.Item
        	If VBA.IsObject(myIter.Item(0)) Then
                Set s.Host(ipIndex) = myIter.Item(0)
            Else
                s.Host(ipIndex) = myIter.Item(0)
            End If
            ipIndex += 1
        Loop While myIter.MoveNext

        Return Me
        
   End Function

  
    
   
    Public Function RemoveRange(ByVal ipIndex As Long, ByVal ipCount As Long) As Object
        Return Me.RemoveAt(ipCount, ipCount)
    End Function
    
    
    Public Function RemoveAt(ByVal ipRemoveIndex As Long, Optional ipCount As Long = 1) As Object
    
        If ipRemoveIndex < 1 Or ipRemoveIndex > s.LastIndex Then
            Return Me
        End If
        
        If ipCount < 1 Then
            Return Me
        End If
        
        If ipRemoveIndex + ipCount > s.LastIndex Then
        
            ipCount = s.LastIndex - ipRemoveIndex + 1
            
        End If
           
        MoveDown ipRemoveIndex, ipCount ' -1 +1 cancels
            
        Return Me
        
    End Function
    
    
    Public Function Repeat(ByVal ipIterator As IterConst) As Object
        
        Do
            DoEvents
            Add ipIterator.Item
        Loop While ipIterator.MoveNext
        
        Return Me
        
    End Function
    
    
    Public Function Repeat(ByVal ipIterator As IterNum) As Object
        
        Do
            DoEvents
           Add ipIterator.Item
        Loop While ipIterator.MoveNext
        
        Return Me
        
    End Function
    
    
    Public Function Repeat(ByRef ipItem As T, ByVal ipCount As Long) As Object
        
        Dim myCount As Long
        For myCount = 1 To ipCount
            Add ipItem
        Next
        Return Me
    End Function
    
    ' Copyto does not work as it stands because VBA does a copy
    ' in when we do VarArray.cargo= Array
    ' If we use Variant, then we cannot use twinbasics overloading
    ' so we will need to write a function to allow us to access
    ' the safearray structure so we can do diret writes.
    '@Description("Makes a shallow copy of the seq in the provided array")
    Public Function CopyTo(ByRef ipArray As Variant) As Object
       
       ' Dim myArray As Variant = ipVarArray.Cargo
        If Guard.IsNotArray(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
        If Guard.IsNotAllocated(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
        If Guard.TooManyRanks(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
        'If Guard.SizeMismatch(s.LastIndex > ArrayInfo.Count(myArray), CurrentComponentName, CurrentProcedureName) Then Return Me
       
        
        Dim myIndex  As Long = VBA.LBound(ipArray)
        Dim myEndIndex As Long = VBA.UBound(ipArray)
        
        Dim myItems As IterItems = IterItems(Me)
        Do
            Dim myItem As Variant = myItems.Item(0)
            
            If VBA.IsObject(myItems.Item(0)) Then
                Set ipArray(myIndex) = myItem
            Else
                ipArray(myIndex) = myItem
            End If
            
            myIndex += 1
            
        Loop While myItems.MoveNext And myIndex <= myEndIndex
        
        Return Me
        
    End Function
    
    
    Public Function CopyTo(ByRef ipArray As Variant, ByVal ipArrayStartIndex As Long) As Object
        
         ' Dim myArray As Variant = ipVarArray.Cargo
        If Guard.IsNotArray(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
        If Guard.IsNotAllocated(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
        If Guard.TooManyRanks(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
        'If Guard.SizeMismatch(s.LastIndex > ArrayInfo.Count(myArray), CurrentComponentName, CurrentProcedureName) Then Return Me
       
        
        Dim myIndex  As Long = ipArrayStartIndex
        Dim myEndIndex As Long = VBA.UBound(ipArray)
        
        Dim myItems As IterItems = IterItems(Me)
        Do
            Dim myItem As Variant = myItems.Item(0)
            
            If VBA.IsObject(myItems.Item(0)) Then
                Set ipArray(myIndex) = myItem
            Else
                ipArray(myIndex) = myItem
            End If
            
            myIndex += 1
            
        Loop While myItems.MoveNext And myIndex <= myEndIndex
        
        Return Me
    End Function
    
    Public Function CopyTo _
    ( _ 
        ByVal ipSeqStartIndex As Long, _
        ByRef ipArray As Variant, _
        ByVal ipArrayStartIndex As Long, _
        ByVal ipArrayCount As Long _
    ) As Object
    
         ' Dim myArray As Variant = ipVarArray.Cargo
        If Guard.IsNotArray(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
        If Guard.IsNotAllocated(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
        If Guard.TooManyRanks(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
        'If Guard.SizeMismatch(s.LastIndex > ArrayInfo.Count(myArray), CurrentComponentName, CurrentProcedureName) Then Return Me
       
        ipSeqStartIndex -= 1
        Dim myIndex  As Long = ipArrayStartIndex
        Dim myEndIndex As Long = ipArrayStartIndex + ipArrayCount - 1
        If myEndIndex > UBound(ipArray) Then
            myEndIndex = UBound(ipArray)
        End If
        Dim myItems As IterItems = IterItems(Me).SetFTS(ipSeqStartIndex)
        Do
            Dim myItem As Variant = myItems.Item(0)
            
            If VBA.IsObject(myItems.Item(0)) Then
                Set ipArray(myIndex) = myItem
            Else
                ipArray(myIndex) = myItem
            End If
            
            myIndex += 1
            
        Loop While myItems.MoveNext And myIndex <= myEndIndex
        
        Return Me
    End Function
    
    ' Public Function CopyTo _
    ' ( _
    '     ByRef ip1SeqStartor2Array As Variant, _
    '     Optional ByRef ip1Arrayor2ArrayStart As Variant = Empty, _
    '     Optional ByRef ip1ArrayStartor2Count As Variant = Empty, _
    '     Optional ByRef ipCount As Variant = Empty, _
    '     Optional ByRef ipEnd As Variant = Empty _
    ' ) as Object
    
    '     ' 8 combinations are allowed, ipEnd must be specified by name if used.
    '     ' 1. seqstart, array
    '     ' 2. seqstart, Array, arraystart
    '     ' 3. seqstart, array, arraystart, arraycount
    '     ' 4. seqstart, array, arraystart ipEnd:=arrayend
    '     ' 5. Array
    '     ' 6. Array, Arraystart
    '     ' 7. Array, ArrayStart, ArrayCount
    '     ' 8. Array, ArrayStart, ipEnd:=ArrayEnd 
    '     Dim mySeqStart As Variant
    '     Dim myArrayStart As Variant
    '     Dim myArrayCount As Variant
    '     Dim myArrayEnd As Variant

    '     If VBA.IsArray(ip1SeqStartor2Array) Then

    '         mySeqStart = 1
    '         myArrayStart = ip1Arrayor2ArrayStart
    '         myArrayCount = ip1ArrayStartor2Count
    '         myArrayEnd = ipEnd

    '         Return CopyToWithSeqStart(mySeqStart, ip1SeqStartor2Array, myArrayStart, myArrayCount, myArrayEnd)
    '     Else

    '         mySeqStart = ip1SeqStartor2Array
    '         myArrayStart = ip1ArrayStartor2Count
    '         myArrayCount = ipCount
    '         myArrayEnd = ipEnd

    '         Return CopyToWithSeqStart(mySeqStart, ip1Arrayor2ArrayStart, myArrayStart, myArrayCount, myArrayEnd)
    '     End If
        	
        
        
    ' End Function
    
    ' Public Function CopyToArrayOnly(ByRef ipArray As Variant) as Object
        
    '     Dim myArrayIndex As Long = VBA.LBound(ipArray)
    '     Dim mySeqIndex As Long
    '     For mySeqIndex = FIRST_INDEX To s.LastIndex
            
    '         If VBA.IsObject(s.Host(mySeqIndex)) Then
    '             Set ipArray(myArrayIndex) = s.Host(mySeqIndex)
                
    '         Else
    '             ipArray(myArrayIndex) = s.Host(mySeqIndex)
    '         End If
    '         myArrayIndex += 1
            
    '     Next
    ' End Function
    
    ' Public Function CopyToWithArrayStart(ByRef ipArray As Variant, ByRef ipArrayStartIndex As Long) as Object
        
    '     Dim myArrayIndex As Long = ipArrayStartIndex
    '     Dim mySeqIndex As Long
    '     For mySeqIndex = FIRST_INDEX To s.LastIndex
            
    '         If VBA.IsObject(s.Host(mySeqIndex)) Then
    '             Set ipArray(myArrayIndex) = s.Host(mySeqIndex)
                
    '         Else
    '             ipArray(myArrayIndex) = s.Host(mySeqIndex)
    '         End If
    '         myArrayIndex += 1
            
    '     Next
        
    ' End Function
    
    ' Public Function CopyToWithSeqStart _
    ' ( _
    '     ByVal ipSeqStart As Long, _
    '     ByRef ipArray As Variant, _
    '     ByRef ipArrayStartIndex As Variant, _
    '     ByRef ipArrayRun As Variant, _
    '     ByRef ipArrayEndIndex As Variant _
    ' ) as Object
        
    '     Dim myArrayStartIndex As Long
    '     Dim myArrayEndIndex As Long
    '     Dim myStartEnd As Variant
    '     myStartEnd = Ranges.ResolveStartEndRun(LBound(ipArray), UBound(ipArray), ipArrayStartIndex, ipArrayRun, ipArrayEndIndex)

    '     Dim myOffset As Long
    '     For myOffset = 0 To myStartEnd(2) - 1
            
    '         If ipSeqStart + myOffset > s.LastIndex Then
    '             Exit For
    '         End If

    '         If VBA.IsObject(s.Host(ipSeqStart + myOffset)) Then
    '             Set ipArray(myStartEnd(0) + myOffset) = s.Host(ipSeqStart + myOffset)
    '         Else
    '             ipArray(myStartEnd(0) + myOffset) = s.Host(ipSeqStart + myOffset)
    '         End If
            
            
    '     Next
        
    ' End Function
    
    ' Public Function ResolveStartRunEnd(ByRef iparray As Variant, ByRef ipStart As Variant, ByRef ipRun As Variant, ByRef ipEnd As Variant) As Variant

    '     Dim myStart As Long
    '     Dim myEnd As Long

    '     Dim myArrayStart As Long = LBound(iparray, 1)
    '     Dim myArrayEnd As Long = UBound(iparray, 1)

    '     If VBA.IsEmpty(ipStart) Or ipStart < myArrayStart Then
    '         myStart = myArrayStart
    '     Else
    '     	myStart = ipStart
    '     End If

    '     If VBA.IsEmpty(ipEnd) Or (ipEnd > myArrayEnd) Then
    '         myEnd = myArrayEnd
    '     Else
    '     	myEnd = ipEnd
    '     End If

    '     ' If run is provided it trumps end
    '     If VBA.IsEmpty(ipRun) Or (myStart + ipRun - 1 > myArrayEnd) Then
    '         myEnd = myArrayEnd
    '     Else
    '     	myEnd = myStart + ipRun - 1
    '     End If

    '     Return Array(myStart, myEnd, myEnd - myStart + 1)

    ' End Function


   
   Public Function GetRange(ByVal ipStartIndex As Long, Optional ByVal ipRun As Variant = Empty, ByVal ipEndIndex As Variant = Empty) As Object
        Return Slice(ipStartIndex, ipRun, ipEndIndex)
   End Function
   
    Public Function Slice _
    ( _
        Optional ByVal ipStartIndex As Variant = Empty, _
        Optional ipRun As Variant = Empty, _
        Optional ipEndIndex As Variant = Empty _
    ) As Object
       'Debug.Print "Under construction"
        Dim myStartIndex As Long
        Dim myRun As Long
        Dim myser As SER = Ranges.ResolveStartEndRun(FIRST_INDEX, LastIndex, ipStartIndex, ipEndIndex, ipRun)
        
        ' The introduction of ResolveStartRunEnd means we always get sane values for 
        ' myStartIndex and myRun so no furthe rchecking of bounds is needed
        Dim myS As Seq = Seq.Deb
        Dim myIndex As Long
        For myIndex = myser.NativeStart To myser.NativeEnd
            myS.Add s.Host(myIndex)
        Next
        
        Return myS
        
    End Function
   
    Public Function SplitAt(ByVal ipIndex As Long) As Object
    
        If ipIndex < 1 Then
        
            Return Seq.Deb.AddItems(Seq.Deb, Seq.Deb)
            
        ElseIf ipIndex = 1 Then
        
            Return Seq.Deb.AddItems(Me, Seq.Deb)
            
        Else
        
            Return Seq.Deb.AddItems(Me.Slice(1, ipIndex - 1), Me.Slice(ipIndex))
        
        End If
    End Function
    
    Public Function Stuff(ByRef ipItem As Variant) As Object
        Return Insert(1, ipItem)
    End Function
    
    Public Function StuffItems(ParamArray ipItems() As Variant) As Object
    	Return InsertRange(1, VBA.CVar(ipItems))
    End Function
    
    Public Function StuffRange(ByRef ipItems As Variant) As Object
        Return InsertRange(1, ipItems)
    End Function
       
    Public Function Clone() As Object
        Return Seq.Deb.AddRange(Me.ToArray)
    End Function
    
    '@Description("Deletes all items in the seq")
    Public Function Clear() As Object
        Return RemoveAll
    End Function
    
    Public Function RemoveAll() As Object
    
        If Count = 0 Then
            Return Me
        End If
        
        Dim myIndex As Long
        For myIndex = LastIndex To FirstIndex Step -1
            s.Host(myIndex) = Empty
        Next
        s.LastIndex = 0
        s.Size = DEFAULT_CHUNK
        Resize
        Return Me
    End Function
    
      '@Description("Removes one(default) or more instances of ipItem from the seq.  A count of -1 removes all instances")
    Public Function Remove(ByRef ipItem As Variant, Optional ByVal ipcount As Long = 1) As Object
    
        Dim myIndex As Long = 1
        Dim myCounter As Long = 0
        Do
        
            If s.Host(myIndex) = ipItem Then
                Me.RemoveAt(myIndex)
                If ipcount = -1 Then
                    Continue Do
                End If
                
                myCounter += 1
                
                If ipcount > myCounter Then
                    Continue Do
                End If
               
            Else
            
                myIndex += 1
                
            End If
            
        Loop Until myIndex > UBound(s.Host)
        
        Return Me
        
    End Function
    
    Public Function Contains(ByRef ipItem As Variant) As Boolean
        Return Me.HoldsItem(ipItem)
    End Function

    '@Description("Moves all elements from ipIndex to s.lastindex down by ipCount places")
    Private Sub MoveDown(ByVal ipToIndex As Long, ByVal ipCount As Long)
      
        If ipCount < 1 Then
            Exit Sub
        End If
        
        ' If ipIndex < FIRST_INDEX Or ipIndex > s.LastIndex Then
        '     Exit Sub
        ' End If
        
        Dim myToIndex As Long = ipToIndex
        
        Dim myFromIndex As Long
        For myFromIndex = ipToIndex + ipCount To s.LastIndex
        
            If VBA.IsObject(s.Host(myFromIndex)) Then
                Set s.Host(myToIndex) = s.Host(myFromIndex)
            Else
            	s.Host(myToIndex) = s.Host(myFromIndex)
            End If
           ' s.Host(myFromIndex) = Empty
            myToIndex += 1
           
            
        Next
        Dim myIndex As Long
        For myIndex = s.LastIndex - ipCount + 1 To s.LastIndex
            s.Host(myIndex) = Empty
        Next
        s.LastIndex -= ipCount
        
    End Sub
    
    '@Description("Moves all elements from ipIndex to s.lastindex up by ipCount places")
    Private Sub MoveUp(ByVal ipIndex As Long, Optional ByVal ipCount As Long = 1)
    	
        If ipCount < 1 Then
            Exit Sub
        End If
        
        If ipIndex < FIRST_INDEX Or ipIndex > s.LastIndex Then
            Exit Sub
        End If

        
        Do While s.LastIndex + ipCount > s.Size
        	DoEvents
            s.Size += DEFAULT_CHUNK
            Resize

        Loop
    
        Dim myToIndex As Long = s.LastIndex + ipCount
        Dim myFromIndex As Long = s.LastIndex
        
        Dim myIterations As Long
        For myIterations = 0 To s.LastIndex - ipIndex

            Assign s.Host(myToIndex - myIterations), s.Host(myFromIndex - myIterations)
            
        Next

        s.LastIndex = s.LastIndex + ipCount
        
    End Sub

    Public Function HoldsItem(ByRef ipItem As Variant) As Boolean 'Implements IIndexed.HoldsItem
        'Me.IsQueryable
        If s.LastIndex < 1 Then
            Return False
        End If
        Dim myIndex As Long
        For myIndex = 1 To s.LastIndex
            Dim myItem As Variant = s.Host(myIndex)
            If myItem = ipItem Then
                Return True
            End If
          
        Next
        Return False
    End Function

    Public Function LacksItem(ByRef ipItem As Variant) As Boolean 'Implements IIndexed.LacksItem
        LacksItem = Not HoldsItem(ipItem)
    End Function

    Public Function MapIt(ByVal ipMapper As IMapper) As Object

        Dim myAL As Seq = Seq.Deb
   
        
        Dim myI As IterItems = IterItems.Deb(Me.TrimToSize)
        Do
            DoEvents
            myAL.Add ipMapper.ExecMapper(myI(0))    '(s.Host(myI.Item))
        Loop While myI.MoveNext

        Return myAL

    End Function

    Public Function FilterIt(ByVal ipComparer As IComparer) As Object

        Dim mySeq As Seq = Seq.Deb
        Dim myI As IterItems = IterItems.Deb(Me)
        Do
            DoEvents
            If ipComparer.ExecCmp(myI(0)) Then mySeq.Add myI(0)
        Loop While myI.MoveNext
        Return mySeq
        
    End Function
    
    Public Function CountIt(ByVal ipComparer As IComparer) As Long
        
        Dim myCount As Long = 0
        Dim myIndex As Long
        For myIndex = FirstIndex To LastIndex
            If ipComparer.ExecCmp(s.Host(myIndex)) Then myCount += 1
        Next

        Return myCount

    End Function
    
    Public Function ReduceIt(ByRef ipReducer As IReducer) As Variant
        Return ipReducer.ExecReduction(Me)
    End Function
    
    Public Property Get First() As Variant
        Return s.Host(FIRST_INDEX)
    End Property
    
    Public Property Let First(ByRef ipItem As Variant)
        s.Host(FIRST_INDEX) = ipItem
    End Property
    
    Public Property Set First(ByRef ipItem As Variant)
        Set s.Host(FIRST_INDEX) = ipItem
    End Property
    
    
    Public Property Get Last() As Variant
        Return s.Host(s.LastIndex)
    End Property
    
    Public Property Let Last(ByRef ipItem As Variant)
        s.Host(s.LastIndex) = ipItem
    End Property
    
    Public Property Set Last(ByRef ipItem As Variant)
        Set s.Host(s.LastIndex) = ipItem
    End Property
        
    
    Public Function FirstIndex() As Variant
        If s.LastIndex < FIRST_INDEX Then
            Return CVErr(9&)
        Else
            Return FIRST_INDEX
        End If
    End Function

    Public Function LastIndex() As Variant
        If s.LastIndex < FIRST_INDEX Then
            Return CVErr(9&)
        Else
            Return s.LastIndex
        End If
    End Function
    
    '@Description("Returns the First but One index or null is no items an in the seq")
    Public Function FBOIndex() As Variant
        If s.LastIndex > FIRST_INDEX Then
            Return FIRST_INDEX + 1
        Else
            Return CVErr(9&)
        End If
    End Function
    
     '@Description("Returns the last but One index or null if there is oly one item in the seq")
    Public Function LBOIndex() As Variant
        If s.LastIndex < FirstIndex + 1 Then
            Return CVErr(9&)
        Else
            Return s.LastIndex - 1
        End If
    End Function
    
    Public Function Count() As Long
        Count = s.LastIndex
    End Function
    
    Public Property Get Capacity() As Long
        Capacity = s.Size
    End Property
    
    '@("Resizes the host array to the specifies capacity, existting values in the capacity range are preserved")
    Public Property Let Capacity(ByVal ipCapacity As Long)
        s.Size = ipCapacity
        Resize
    End Property
    
    
    
    Public Function IndexOf _
    ( _
        ByVal ipItem As Variant, _
        Optional ipStart As Variant = Empty, _
        Optional ipEnd As Variant = Empty, _
        Optional ipRun As Variant = Empty _
    ) As Long

        Dim mySER As SER = Ranges.ResolveStartEndRun(FIRST_INDEX, LastIndex, ipStart, ipEnd, ipRun)
        ' Dim myStartIndex As Long
        ' Dim myEndIndex As Long
        
        ' Select Case True
            
        '     Case TypeInfo.IsNumber(ipStartIndex) And TypeInfo.IsNumber(ipRun)
                
        '         myStartIndex = ipStartIndex
        '         myEndIndex = ipStartIndex + ipRun - 1
                
        '     Case TypeInfo.IsNumber(ipStartIndex) And TypeInfo.IsNumber(ipEndIndex)
            
        '         myStartIndex = ipStartIndex
        '         myEndIndex = ipEndIndex
                
        '     Case TypeInfo.IsNumber(ipStartIndex)
            
        '         myStartIndex = ipStartIndex
        '         myEndIndex = s.LastIndex
                
        '     Case TypeInfo.IsNumber(ipRun)
            
        '         myStartIndex = FIRST_INDEX
        '         myEndIndex = FIRST_INDEX + ipRun - 1
                
                
        '     Case TypeInfo.IsNumber(ipEndIndex)
            
        '         myStartIndex = FIRST_INDEX
        '         myEndIndex = ipEndIndex
                
        '     Case Else
            
        '         myStartIndex = FIRST_INDEX
        '         myEndIndex = s.LastIndex
                
        ' End Select
        
        Dim myIndex As Long
        For myIndex = mySER.NativeStart To mySER.NativeEnd
            If s.Host(myIndex) = ipItem Then Return myIndex
        Next
        Return -1
    End Function

    Public Function LastIndexOf(ByVal ipItem As Variant) As Long

        Dim myIndex As Long
        For myIndex = s.LastIndex To FIRST_INDEX Step -1
            If s.Host(myIndex) = ipItem Then Return myIndex
        Next
        Return -1
    End Function
    
    Public Function Join(Optional ByVal ipSeparator As String = char.twcomma) As String
        
       ' If TypeInfo.IsString(s.Host.item(0)) Then
            On Error Resume Next
            Dim myString As String = VBA.Join(Me.ToArray, ipSeparator)
            On Error GoTo 0
            Return myString


        ' Else
        	
        '     Return vbNullString


        ' End If
    	
    End Function
    
    Public Function TrimToSize() As Object
        If s.LastIndex > 0 Then
            ReDim Preserve s.Host(FIRST_INDEX To s.LastIndex)
        End If
        Return Me
    End Function
    
    
    Private Sub Resize()
        If s.Size < 1 Then
            ReDim Preserve s.Host(1 To DEFAULT_CHUNK)
        Else
            ReDim Preserve s.Host(1 To s.Size)
        End If
        
    End Sub

    
    Public Function TypeName() As String
        Return MY_TYPENAME
    End Function

    Public Function IsQueryable() As Boolean
        Return Count > 0
    End Function
    
    Public Function IsNOtQueryable() As Boolean
        Return Count < 1
    End Function
    
    Public Function HasItems() As Boolean
        Return Count > 1
    End Function
    
    Public Function HasAnyItems() As Boolean
        Return Count > 0
    End Function
    
    Public Function HasOneItem() As Boolean
        Return Count = 1
    End Function
    
    Public Function ToCollection() As Collection
        Dim myC As Collection
        Dim myI As IterItems = IterItems.Deb(Me)
        Do
            myC.Add myI(0)
        Loop While myI.MoveNext
        Return myC
    End Function
    
    Public Function Push(ByRef ipItem As T) As Object
        Me.Add ipItem
        Return Me
    End Function
    
    Public Function PushItems(ParamArray ipParamArray() As Variant) As Object
        Return AddItems(CVar(ipParamArray))
    End Function
    
    Public Function PushRangs(ByRef ipRange As Variant) As Object
        Return AddRange(ipRange)
    End Function
    
    Public Function Queue(ByRef ipItem As T) As Object
        Add ipItem
        Return Me
    End Function
    
    Public Function QueueItems(ParamArray ipParamArray() As Variant) As Object
        Return AddItems(CVar(ipParamArray))
    End Function
    
    Public Function QueueRange(ByRef ipRange As Variant) As Object
        Return AddRange(ipRange)
    End Function
    
    
    Public Function RotL(Optional ByVal ipCount As Long = 1) As Object
        Dim mycount As Long
        For mycount = 1 To ipCount
            AddItems Dequeue
        Next
        Return Me
    End Function
    
    Public Function RotR(Optional ByVal ipcount As Long = 1) As Object
        Dim mycount As Long
        For mycount = 1 To ipcount
            Insert 1, Pop
        Next
        Return Me
    End Function
    
    Public Function Pop(Optional ipCount As Long = 1) As Variant
        
        If ipCount < 1 Then
            Return Null
        End If
        
        Dim mySeq As Seq = Seq.Deb
        Dim myCount As Long
        For myCount = 1 To ipCount
            mySeq.Add Me.Last
            Me.RemoveAt(Me.LastIndex)
        Next
        
        If mySeq.Count = 1 Then
            Return mySeq.First
        Else
        	Return mySeq
        End If
        
        ' Dim myA As Variant = Me.Slice(s.LastIndex - ipCount + 1, s.LastIndex).ToArray
        ' Me.RemoveAt(s.LastIndex - ipCount + 1, ipCount)
        ' If ipCount = 1 Then
        '     Return myA(0)
        ' Else
        ' 	Return myA
        ' End If
        
    End Function
    
    Public Function Dequeue(Optional ipCount As Long = 1) As Variant
        
        If ipCount < 1 Then
            Return Null
        End If
        
        Dim myA As Variant = Slice(FIRST_INDEX, iprun:=ipCount).ToArray
        Me.RemoveAt(FIRST_INDEX, ipCount)
        Return IIf(ipCount = 1, myA(0), myA)
       
    End Function
    
    Public Function Sort() As Variant
        Cops.SortInPlace Me
        Return Me
    End Function
    
    Public Function Swap(ByRef ipLHS As Long, ByVal ipRHS As Long) As Object
    	Dim myTmp As Variant
        If VBA.IsObject(s.Host(ipLHS)) Then
            Set myTmp = s.Host(ipLHS)
        Else
            myTmp = s.Host(ipLHS)
        End If
        
        If VBA.IsObject(s.Host(ipRHS)) Then
            Set s.Host(ipLHS) = s.Host(ipRHS)
        Else
            s.Host(ipLHS) = s.Host(ipRHS)
        End If
        If VBA.IsObject(myTmp) Then
            Set s.Host(ipRHS) = myTmp
        Else
            s.Host(ipRHS) = myTmp
        End If
        
        Return Me
    End Function
    
    Public Function Reverse() As Object
    
        ' we need to reverse in place
       
        Dim myArray As Variant
        ReDim myArray(LBound(s.Host, 1) To UBound(s.Host, 1))
        
        
        Dim myindex As Long = 1
        Dim myReverseIndex As Long
        For myReverseIndex = LastIndex To FirstIndex Step -1
            
            myArray(myReverseIndex) = s.Host(myindex)
            myindex += 1
        Next
        
        s.Host = myArray
        ' Dim myReversed As Seq = Seq.Deb
        ' Dim myItems As IterItems = IterItems.Deb(Me).MoveToEnd
        ' Do
        ' 	myReversed.Add myItems(0)
        ' Loop While myItems.MovePrev
         Return Me
        
    End Function

    Public Function Set(ByVal ipSet As SetOf, ipParam As Seq) As Object
        Return Cops.Set(ipSet, Me, ipParam)
    End Function
    
    Public Function Merge(ByRef ipParam As Variant) As Object
    	Return Me.AddRange(ipParam)
    End Function
    
    Public Function Host() As Variant 'Implements IIndexed.Host
        Return Items
    End Function
    
    Public Function IsUnique() As Boolean
        
        Dim myFreqs As Hkvp = Me.Freq
        Dim myIter As IterItems = IterItems.Deb(myFreqs)
        Do
        	
            If myIter.Item(0) > 1 Then
            
                Return False
                
            End If
            
        Loop While myIter.MoveNext
        
        Return True
        
    End Function
    
    Public Function IsNotUnique() As Boolean
        Return Not IsUnique
    End Function
    
    
    Public Function Freq() As Hkvp
    
        Dim myHkvp As Hkvp = Hkvp.Deb
        
            Dim myIter As IterItems = IterItems.Deb(Me)
            Do
                
                If myHkvp.HoldsKey(myIter(0)) Then
                
                    myHkvp.Item(myIter(0)) += 1
                
                
                Else
                    
                    myHkvp.Add myIter(0), 1
                    
                    
                End If
                
            Loop While myIter.MoveNext
        
        Return myHkvp
        
    End Function
    
    '@Description(creates an hkvp of collections items where the items in the collection are bucketed based on the value at an Index)
    Public Function Freq(ByVal ipIndex As Long) As Hkvp
    
        Dim myHkvp As Hkvp = Hkvp.Deb
        
            Dim myIter As IterItems = IterItems.Deb(Me)
            Do
                
                If myHkvp.HoldsKey(myIter(0)(ipIndex)) Then
                
                    myHkvp.Item(myIter(0)(ipIndex)).add myIter(0)
                
                
                Else
                    
                    myHkvp.Add myIter(0)(0), Seq.Deb
                    
                    
                End If
                
            Loop While myIter.MoveNext
        
        Return myHkvp
        
    End Function

End Class