Class cHashD

    Attribute VB_GlobalNameSpace = False
    Attribute VB_Creatable = True
    Attribute VB_PredeclaredId = False
    Attribute VB_Exposed = True
    Option Explicit
    '@Description("DIctionary based on cHashD by Olaf Schmidt August 2016 (enhanced about mixed, variable KeyTypes and Remove-functions in 2020")

    Private Const NoEntry As Variant = Empty
    Private Const DynTakeOver As Long = 4, HMul As Long = 3727 'fixed HashSlot-amount and Hash-Multiplikator

    Private Type HashTableEntry
    Count As Long
    DataIdxsStat(0 To DynTakeOver - 1) As Long
    DataIdxsDyn() As Long
    End Type
    
    Private W() As Integer, saW As SAFEARRAY1D
    
    Private mLastExpectedMaxCount As Long, mEnsureUniqueKeys As Boolean, mLastH As Long
    Private mCount As Long, mDTUB As Long, mHashTableSize As Long, mCompareMode As VbCompareMethod
    Private HashTable() As HashTableEntry, mKeys() As variant, mValues() As variant  'both pairing-arrays are of type Variant
    Private mFIndexes() As Long, mFCount As Long, mFUB As Long 'three vars, to handle the deletes


    ' Public Function Deb() As cHashD
    '     With New cHashD
    '         Return .ConstructInstance
    '     End With
    ' End Function

    'Friend Function ConstructInstance() As cHashD
    Private Sub Class_Initialize()
        saW.cDims = 1:  saW.cbElements = 2
        saW.cLocks = 1: saW.fFeatures = &H11 'FADF_AUTO=&H1 || FADF_FIXEDSIZE=&H10
        BindArray W, VarPtr(saW)
    
        mCompareMode = vbBinaryCompare
        ReInit 16384'at startup we set it up, to behave ideally for up to 16384 Items with unique keys
        
        If LWC(97) = 0 Then InitLWC
    '     Return Me
    ' End Function
    End Sub

    Public Sub ReInit(Optional ByVal ExpectedMaxCount As Long, Optional ByVal EnsureUniqueKeys As Boolean)
        If ExpectedMaxCount <= 0 Then ExpectedMaxCount = mLastExpectedMaxCount
        If ExpectedMaxCount < 128 Then ExpectedMaxCount = 128
        mLastExpectedMaxCount = ExpectedMaxCount
        mEnsureUniqueKeys = EnsureUniqueKeys
        
        mHashTableSize = 16
        Do Until mHashTableSize * 2 > ExpectedMaxCount: mHashTableSize = mHashTableSize * 2: Loop
        If mHashTableSize > 524288 Then mHashTableSize = 524288
        ReDim HashTable(0 To mHashTableSize - 1)
        
        mDTUB = mLastExpectedMaxCount
        ReDim mKeys(0 To mDTUB)
        ReDim mValues(0 To mDTUB)
        mCount = 0
        mFCount = 0: mFUB = 16: ReDim mFIndexes(0 To mFUB)
    End Sub

    Public Sub Clear()
        ReInit
    End Sub

    Public Property Get Count() As Long
        Return mCount
    End Property

    Public Property Get HasUniqueKeys() As Boolean
        Return mEnsureUniqueKeys
    End Property

    Public Property Get StringCompareMode() As VbCompareMethod
        Return mCompareMode
    End Property

    Public Property Let StringCompareMode(ByVal RHS As VbCompareMethod)
        mCompareMode = RHS
    End Property
    
    Public Function Keys() As Variant()
        If mCount = 0 Then Keys = Array(): Exit Function
        
        Dim i As Long, j As Long, V() As Variant: ReDim V(0 To mCount - 1)
        For i = 0 To mCount - 1
            Do While IsEmpty(mKeys(j)): j = j + 1: Loop
            VariantCopy V(i), ByVal VarPtr(mKeys(j)): j = j + 1
        Next
        
        Return V
    End Function

    Public Function Items() As Variant()
        If mCount = 0 Then Items = Array(): Exit Function
        
        Dim i As Long, j As Long, V() As Variant: ReDim V(0 To mCount - 1)
        For i = 0 To mCount - 1
            Do While IsEmpty(mKeys(j)): j = j + 1: Loop
            VariantCopy V(i), ByVal VarPtr(mValues(j)): j = j + 1
        Next
        
        Return V
    End Function

    Public Function Pairs() As Variant() 'hand-out the Key-Values in a Pairs-Array
        If mCount = 0 Then Pairs = Array(): Exit Function
        
        Dim i As Long, j As Long, V() As Variant: ReDim V(0 To mCount - 1)
        For i = 0 To mCount - 1
            Do While IsEmpty(mKeys(j)): j = j + 1: Loop
            V(i) = Array(mKeys(j), mValues(j)): j = j + 1
        Next
        
        Return V
    End Function
    
    Public Function PairsSeq() As Seq 'hand-out the Key-Values in a seq of pair arrays
    
        If mCount = 0 Then
            Return Seq.Deb
        End If
        
        Dim myResult As Seq = Seq.Deb
       
        Dim myKeys As IterItems = IterItems(mKeys)
        Dim myItems As IterItems = IterItems(mValues)
        Do
            If myKeys.ItemIsNotEmpty Then
                myResult.AddItems Array(myKeys.Item(0), myItems.Item(0))
           End If
        Loop While myKeys.MoveNext And myItems.MoveNext
        
        Return myResult
        
    End Function
    
    Public Function Exists(Key As Variant) As Boolean
        Exists = FindIndex(Key) >= 0
    End Function

    Public Sub Add(Key As Variant, Item As Variant)
        Dim H As Long, UB As Long, i As Long
        If mLastH Then
            H = mLastH: mLastH = 0
        ElseIf mEnsureUniqueKeys Then
            If FindIndex(Key, H) >= 0 Then Err.Raise 457
        Else
            H = -1: FindIndex Key, H 'a Value of -1 for H will skip the Index-Search, returning only H
        End If
        
        'add the new Pair, prolonging the Keys- and Values-arrays
        If mDTUB < mCount Then
            mDTUB = (mDTUB + 16) * 1.3
            ReDim Preserve mKeys(0 To mDTUB)
            ReDim Preserve mValues(0 To mDTUB)
        End If
        
        If mFCount > 0 Then
            mFCount = mFCount - 1: i = mFIndexes(mFCount)
        Else
            i = mCount
        End If
        VariantCopyInd ByVal VarPtr(mValues(i)), ByVal VarPtr(Item)
        VariantCopyInd ByVal VarPtr(mKeys(i)), ByVal VarPtr(Key)
        
        'add the new DataIndex to the proper Hash-Buckets
        Select Case HashTable(H).Count
            Case Is < DynTakeOver
            HashTable(H).DataIdxsStat(HashTable(H).Count) = i
            Case DynTakeOver
            ReDim Preserve HashTable(H).DataIdxsDyn(DynTakeOver To DynTakeOver + 3)
            HashTable(H).DataIdxsDyn(DynTakeOver) = i
            Case Else
            UB = UBound(HashTable(H).DataIdxsDyn)
            If UB < HashTable(H).Count Then UB = (UB + 3) * 1.3: ReDim Preserve HashTable(H).DataIdxsDyn(DynTakeOver To UB)
            HashTable(H).DataIdxsDyn(HashTable(H).Count) = i
        End Select
        HashTable(H).Count = HashTable(H).Count + 1
        
        mCount = mCount + 1
    End Sub

    Public Sub Remove(Key As Variant)
        If mCount = 0 Then Exit Sub
        Dim H As Long, Idx As Long, i As Long, j As Long
            Idx = FindIndex(Key, H)
            If Idx < 0 Then Err.Raise 5
            
            For i = 0 To HashTable(H).Count - 2
            If i < DynTakeOver Then
                If j = 0 Then If HashTable(H).DataIdxsStat(i) = Idx Then j = i + 1
                If j Then
                    If j < DynTakeOver Then
                    HashTable(H).DataIdxsStat(i) = HashTable(H).DataIdxsStat(j): j = j + 1
                    Else
                    HashTable(H).DataIdxsStat(i) = HashTable(H).DataIdxsDyn(j): j = j + 1
                    End If
                End If
            Else
                If j = 0 Then If HashTable(H).DataIdxsDyn(i) = Idx Then j = i + 1
                If j Then HashTable(H).DataIdxsDyn(i) = HashTable(H).DataIdxsDyn(j): j = j + 1
            End If
            Next
            HashTable(H).Count = i
            
            If mFUB < mFCount Then mFUB = mFUB + mFUB: ReDim Preserve mFIndexes(0 To mFUB)
            mFIndexes(mFCount) = Idx: mFCount = mFCount + 1
            
            mKeys(Idx) = NoEntry
            mValues(Idx) = NoEntry
            mCount = mCount - 1
    End Sub

    Public Sub RemoveByIndex(ByVal IndexZeroBased As Long)
        Remove KeyByIndex(IndexZeroBased)
    End Sub

    Public Function IndexByKey(Key As Variant) As Long
        Dim Idx As Long
            Idx = FindIndex(Key)
        If Idx >= 0 And mFCount > 0 Then AdjustIndex Idx, True
        Return Idx
    End Function

    Public Property Get KeyByIndex(ByVal ipIndexZeroBased As Long) As Variant
        If ipIndexZeroBased < 0 Or ipIndexZeroBased >= mCount Then Err.Raise 9
        If mFCount Then AdjustIndex ipIndexZeroBased
        VariantCopy KeyByIndex, ByVal VarPtr(mKeys(ipIndexZeroBased))
    End Property

    Public Property Get ItemByIndex(ByVal ipIndexZeroBased As Long) As Variant
        If ipIndexZeroBased < 0 Or ipIndexZeroBased >= mCount Then Err.Raise 9
        If mFCount Then AdjustIndex ipIndexZeroBased
        VariantCopy ItemByIndex, ByVal VarPtr(mValues(ipIndexZeroBased))
    End Property

    Public Property Let ItemByIndex(ByVal ipIndexZeroBased As Long, RHS As Variant)
        If ipIndexZeroBased < 0 Or ipIndexZeroBased >= mCount Then Err.Raise 9
        If mFCount Then AdjustIndex ipIndexZeroBased
        VariantCopyInd ByVal VarPtr(mValues(ipIndexZeroBased)), ByVal VarPtr(RHS)
    End Property

    Public Property Set ItemByIndex(ByVal ipIndexZeroBased As Long, RHS As Variant)
        If ipIndexZeroBased < 0 Or ipIndexZeroBased >= mCount Then Err.Raise 9
        If mFCount Then AdjustIndex ipIndexZeroBased
        VariantCopyInd ByVal VarPtr(mValues(ipIndexZeroBased)), ByVal VarPtr(RHS)
    End Property

    '@DefaultMember
    Public Property Get Item(Key As Variant) As Variant
        Attribute Item.VB_UserMemId = 0
        Dim Index As Long
        Index = FindIndex(Key)
        If Index >= 0 Then
            VariantCopy Item, ByVal VarPtr(mValues(Index))
        End If
    End Property

    ' we don't want the property of Item adding a key if it doesn't exist
    Public Property Let Item(Key As Variant, RHS As Variant)
        Dim Index As Long:  Index = FindIndex(Key, mLastH)
        'If Index = -1 Then Add Key, RHS Else VariantCopyInd ByVal VarPtr(mValues(Index)), ByVal VarPtr(RHS)
        If Index = -1 Then
            Err.Raise 17 + vbObjectError, "Lib.cHashD.LetItem", "Key does not exist"
        Else
        	VariantCopyInd ByVal VarPtr(mValues(Index)), ByVal VarPtr(RHS)
        End If
        mLastH = 0
    End Property

    Public Property Set Item(Key As Variant, RHS As Variant)
        Dim Index As Long:  Index = FindIndex(Key, mLastH)
        'If Index = -1 Then Add Key, RHS Else VariantCopyInd ByVal VarPtr(mValues(Index)), ByVal VarPtr(RHS)
        If Index = -1 Then
            Err.Raise 17 + vbObjectError, "Lib.cHashD.SetItem", "Key does not exist"
        Else
        	VariantCopyInd ByVal VarPtr(mValues(Index)), ByVal VarPtr(RHS)
        End If
        mLastH = 0
    End Property
    
    Private Function FindIndex(Key As Variant, Optional H As Long) As Long  'return -1, when no Key can be found
        Dim i As Long, C@, D#, L As LongPtr, F!, VT As VbVarType, HTUB As Long
        HTUB = mHashTableSize - 1
        FindIndex = H
        H = HTUB 'init the HashValue (all bits to 1)
        
        VT = VarType(Key)
        Select Case VT
            Case vbString
            saW.cElements1D = Len(Key): saW.pvData = StrPtr(Key)
            If mCompareMode = 0 Then
                For i = 0 To saW.cElements1D - 1: H = (H + W(i)) * HMul And HTUB: Next
                If FindIndex = -1 Then Exit Function 'it's a "Hash-Only" Calculation
                
                For i = 0 To HashTable(H).Count - 1
                If i < DynTakeOver Then FindIndex = HashTable(H).DataIdxsStat(i) Else FindIndex = HashTable(H).DataIdxsDyn(i)
                If VarType(mKeys(FindIndex)) = VT Then If Key = mKeys(FindIndex) Then Exit Function
                Next
            Else
                For i = 0 To saW.cElements1D - 1: H = (H + LWC(W(i))) * HMul And HTUB: Next
                If FindIndex = -1 Then Exit Function 'it's a "Hash-Only" Calculation
                
                For i = 0 To HashTable(H).Count - 1
                If i < DynTakeOver Then FindIndex = HashTable(H).DataIdxsStat(i) Else FindIndex = HashTable(H).DataIdxsDyn(i)
                If VarType(mKeys(FindIndex)) = VT Then If StrComp(Key, mKeys(FindIndex), mCompareMode) = 0 Then Exit Function
                Next
            End If
            
            Case vbObject
                L = ObjPtr(Key): saW.cElements1D = 2: saW.pvData = VarPtr(L)
                H = (H + W(0)) * HMul And HTUB 'loop-unrolling (we have only 2 16Bit integers in the array)
                H = (H + W(1)) * HMul And HTUB
            If FindIndex = -1 Then Exit Function 'it's a "Hash-Only" Calculation
            
            For i = 0 To HashTable(H).Count - 1
                If i < DynTakeOver Then FindIndex = HashTable(H).DataIdxsStat(i) Else FindIndex = HashTable(H).DataIdxsDyn(i)
                If VarType(mKeys(FindIndex)) = VT Then If Key Is mKeys(FindIndex) Then Exit Function
            Next
            
            Case vbCurrency
            C = Key: saW.cElements1D = 4: saW.pvData = VarPtr(C)
                H = (H + W(0)) * HMul And HTUB 'loop-unrolling (we have only 4 16Bit integers in the array)
                H = (H + W(1)) * HMul And HTUB
                H = (H + W(2)) * HMul And HTUB
                H = (H + W(3)) * HMul And HTUB
            If FindIndex = -1 Then Exit Function 'it's a "Hash-Only" Calculation
            
            For i = 0 To HashTable(H).Count - 1
                If i < DynTakeOver Then FindIndex = HashTable(H).DataIdxsStat(i) Else FindIndex = HashTable(H).DataIdxsDyn(i)
                If VarType(mKeys(FindIndex)) = VT Then If C = mKeys(FindIndex) Then Exit Function
            Next
            
            Case vbLong, vbInteger, vbByte
            L = Key: saW.cElements1D = 2: saW.pvData = VarPtr(L)
                H = (H + W(0)) * HMul And HTUB 'loop-unrolling (we have only 2 16Bit integers in the array)
                H = (H + W(1)) * HMul And HTUB
            If FindIndex = -1 Then Exit Function 'it's a "Hash-Only" Calculation
            
            For i = 0 To HashTable(H).Count - 1
                If i < DynTakeOver Then FindIndex = HashTable(H).DataIdxsStat(i) Else FindIndex = HashTable(H).DataIdxsDyn(i)
                Select Case VarType(mKeys(FindIndex))
                Case vbLong, vbInteger, vbByte: If L = mKeys(FindIndex) Then Exit Function
                End Select
            Next
        
            Case vbDouble
            D = Key: saW.cElements1D = 4: saW.pvData = VarPtr(D)
                H = (H + W(0)) * HMul And HTUB 'loop-unrolling (we have only 4 16Bit integers in the array)
                H = (H + W(1)) * HMul And HTUB
                H = (H + W(2)) * HMul And HTUB
                H = (H + W(3)) * HMul And HTUB
            If FindIndex = -1 Then Exit Function 'it's a "Hash-Only" Calculation
                    
            For i = 0 To HashTable(H).Count - 1
                If i < DynTakeOver Then FindIndex = HashTable(H).DataIdxsStat(i) Else FindIndex = HashTable(H).DataIdxsDyn(i)
                If VarType(mKeys(FindIndex)) = VT Then If D = mKeys(FindIndex) Then Exit Function
            Next
            
            Case vbDate
            D = Key: saW.cElements1D = 4: saW.pvData = VarPtr(D)
                H = (H + W(0)) * HMul And HTUB 'loop-unrolling (we have only 4 16Bit integers in the array)
                H = (H + W(1)) * HMul And HTUB
                H = (H + W(2)) * HMul And HTUB
                H = (H + W(3)) * HMul And HTUB
            If FindIndex = -1 Then Exit Function 'it's a "Hash-Only" Calculation
                    
            For i = 0 To HashTable(H).Count - 1
                If i < DynTakeOver Then FindIndex = HashTable(H).DataIdxsStat(i) Else FindIndex = HashTable(H).DataIdxsDyn(i)
                If VarType(mKeys(FindIndex)) = VT Then If D = mKeys(FindIndex) Then Exit Function
            Next
            
            Case vbSingle
            F = Key: saW.cElements1D = 2: saW.pvData = VarPtr(F)
                H = (H + W(0)) * HMul And HTUB 'loop-unrolling (we have only 2 16Bit integers in the array)
                H = (H + W(1)) * HMul And HTUB
            If FindIndex = -1 Then Exit Function 'it's a "Hash-Only" Calculation
                    
            For i = 0 To HashTable(H).Count - 1
                If i < DynTakeOver Then FindIndex = HashTable(H).DataIdxsStat(i) Else FindIndex = HashTable(H).DataIdxsDyn(i)
                If VarType(mKeys(FindIndex)) = VT Then If F = mKeys(FindIndex) Then Exit Function
            Next
        End Select
        
        FindIndex = -1

    End Function

    Private Sub AdjustIndex(Idx As Long, Optional ByVal Inverse As Boolean)
        Dim i As Long, Incr As Long
        If Inverse Then Incr = -1 Else Incr = 1
        For i = 0 To mFCount - 1
            If mFIndexes(i) <= Idx Then Idx = Idx + Incr
        Next
    End Sub

    Friend Sub CheckHashDistribution()
        Dim i As Long, Count As Long, cc As Long, Min As Long, Max As Long
        Min = &H7FFFFFFF
        For i = 0 To UBound(HashTable)
            Count = HashTable(i).Count
            If Count Then
            If Min > Count Then Min = Count
            If Max < Count Then Max = Count
            cc = cc + 1
            End If
        Next
        Debug.Print "Distribution of" ; mCount ; "entries over a HashTable with" ; UBound(HashTable) + 1 ; "slots:"
        Debug.Print "Used-HashSlots:" ; cc
        Debug.Print "Min-Entries:" ; Min
        Debug.Print "Max-Entries:" ; Max
    End Sub



End Class